#!/usr/bin/env bash
level="$1" # INFO (stdout) or ERROR (stderr)
while read -r INPUT
do

	# there are potentially three timestamps: from filebeat reading the log, from the container processing the output and the output itself
	# internal message must implement following properties in this order: origin, @timestamp, source, level,
  # when implementing custom handler: if INPUT starts with '{ "origin": ' then the message is generated by the platform and should be in format alreayd
  source="logger"
	if [[ "$INPUT" == '{ "origin": '*'}' ]] ; then

		printf '%s\n' "$INPUT"

	else

		timestamp=$( to-timestamp )
		if [[ "$INPUT" == "20"* ]] ; then
			case $(echo $INPUT | cut -d ']' -f6 | cut -d ' ' -f2 ) in
				*"INFO"*)
					level="INFO"
					;;
				*"WARN"*)
					level="WARNING"
					;;
				*"ERROR"*)
					level="ERROR"
					;;
				*)
					level="INFO"
					;;
			esac

			part1=$(echo $INPUT | cut -d ']' -f1-5 )
			part2=$(echo $INPUT | cut -d ']' -f6 | cut -d ' ' -f3- )
			message="$part2 $part1"
			if [[ "$message" == 'RestClient - request ['* ]] ; then
				source="streamsets"
			fi
			message=$(echo "$message" | jq -aR . )

		else

			if [[ "${INPUT:0:1}" =~ [a-z] ]] ; then
				level="STACKTRACE"
			else
				level="INFO"
			fi
			message=$(echo $INPUT | jq -aR . )

		fi

		printf '{ "origin": "%s", "@timestamp": "%s", "source": "%s", "level": "%s", "message":%s }\n' "$CONTECO_IMAGE" "$timestamp" "$source" "$level" "$message"

	fi

done
